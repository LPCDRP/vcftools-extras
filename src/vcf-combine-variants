#!/usr/bin/env python
# Kellie Kim, Tal Shmaya August 24, 2016
# Usage: python combine.py file.vcf.gz
# Combines consecutive snps/deletions/insertions

import pysam
from pysam import VariantFile
from operator import itemgetter
import sys
import vcf
import collections

# infile = a vcf.gz file
# output = a list of lists containing groups of consecutive variants
class CombineConsecVariants():
 	def __init__(self):
		self.clist = [] # List containing consecutive positions
		self.dlist = [] # List containing duplicate entries

	# getters
	def get_consec_list(self):
		return self.clist

	def get_dup_list(self):
		return self.dlist

	#check if a pair of ref alt is a snp, insertion or deletion, also returns how many bases are inserted/deleted
	def check_type(self, entry):
		# If entry is a pysam record
		if isinstance(entry,pysam.cbcf.VariantRecord):
		    ref = entry.ref
		    alt = "".join(entry.alts)

		    if len(ref)==len(alt):
			return "snp", 0 
		    if len(ref)<len(alt):
			insert_len=len(alt)-len(ref)
			return "insertion", insert_len
		    if len(ref)>len(alt):
			delete_len=len(ref)-len(alt)
			return "deletion", delete_len
		    else:
			print "something is wrong"

		# If entry is a pyvcf record
		elif isinstance(record,vcf.model._Record):
		    ref = entry.REF
		    alt = "".join(entry.ALT)

		    if len(ref)==len(alt):
			return "snp", 0 
		    if len(ref)<len(alt):
			insert_len=len(alt)-len(ref)
			return "insertion", insert_len
		    if len(ref)>len(alt):
			delete_len=len(ref)-len(alt)
			return "deletion", delete_len
		    else:
			print "something is wrong"
			
	# setters
	def set_consec_list(self, consecutive_list):
		self.clist = consecutive_list

	def set_dup_list(self, duplicate_list):
		self.dlist = duplicate_list

	# Creates list with index for each base in vcf record
	def populate_list(self,ref_alt,pos):
	    ref_alt_list=[]
	    for i,base in enumerate(ref_alt):
		ref_alt_list.append((base,i+pos))

	    return ref_alt_list

	# Checks if the group of consecutive variants passed in has consecutive snps, returns if there are either consecutive snps or dels, the index of the first occurrence and the length
	def contains_consec(self,group,snp_or_del):
		contains_consec = False
		first_occur = -1
		length = -1
		prev_id = ""
		snp_counts = 1
		del_counts = 1
		prev_id = ""

		for index,entry in enumerate(group):
			entry_type = self.check_type(entry)[0]

			# First entry in group
			if prev_id == "":
				prev_id = entry_type

			else:
				if prev_id == entry_type:
					if prev_id == "snp":
						snp_counts += 1
					elif prev_id == "del":
						del_counts += 1
				
				elif prev_id != entry_type:
					if snp_counts > 1 and snp_or_del == "snp":
						contains_consec = True
						length = snp_counts
						return contains_consec,index,length

					elif del_counts > 1 and snp_or_del == "del":
						contains_consec = True
						length = del_counts
						return contains_consec,index,length

					snp_counts = 1
					del_counts = 1

		# No consecutive snps or dels found
		return	contains_consec,index,length

	def set_consecutive_entries(self, infile):
	    """
	    Groups consecutive variants into lists contained within a list.
	    """
	    # Step 1: group consecutive positions into lists ([[position, reference, alternate]]) 
	    # Modeled after gerrymander by Afif
	    vcf_in = VariantFile(infile)
	    vcf_out = [] # List of records which we will write to the new vcf file
	    consecutives, duplicates = [], []
	    block, to_process = [], []
	    distance, last_position = 0, 0
	    duplicate = False
		
	    counts = 0	
	    # Iterate through numbered records in pysam file object
	    for record in vcf_in:
		distance = record.pos - last_position

		# Hit duplicate entry, reset block and add block
		if distance == 0: # Duplicate entry
			duplicate = True
	
		# Hit non-consecutive entry or the first entry of a new block, reset block and add block
		elif distance > 1:
			# First entry in entire file
			if counts == 0:
				counts += 1

			else:
				# Only add the block to process if the length is greater than one
				# Extend consecutives list
				if len(block) > 1 and duplicate == False:
				#	print "adding " + str(block[0].pos) + " to consecs"
					consecutives.append(block)
				
				# Extend duplicates list
				elif len(block) > 1 and duplicate == True:
				#	print "adding " + str(block[0].pos) + " to dups"
					duplicates.append(block)
					duplicate = False

				# Write out single record to vcf file
				elif len(block) == 1:
					vcf_out.append(block[0])
				block = []

		# Consecutive entries, append to current block
		else: 
			distance = 0

		# Add a tuple containing: position, reference, alt
		block.append(record)
		last_position = record.pos

	    # Add last block to it's proper place
	    # If the last block contains more than one entry, add it
	    if len(block) > 1 and duplicate == False:
		consecutives.append(block)

	    elif len(block) > 1 and duplicate == True:
		duplicates.append(block)

	    else:
		vcf_out.append(block[0])

	    ignore_group = False
		

	    """ Ignoring multi-position filtering for now
	    # Filter out groups which contain refs and alts of lengths greater than 2
	    for group in consecutives[1:]:
	        for entry in group:
			# Only process if lengths of ref and alt are less than 2
			if len(entry.ref) > 2 or len("".join(entry.alts)) > 2:
				ignore_group = True

		if ignore_group != True:
			to_process.append(group)

		ignore_group = False # Reset for every group processed
	    """

	    self.set_consec_list(consecutives)
	   # self.set_consec_list(to_process)
	    self.set_dup_list(duplicates)
	    return vcf_out # Return list of single records and dictionary of consec records

	def combine_variants(self, consecutive_list):
	    merged_variants = []
	    previous_id, current_id = "", ""
	    MR, MA = "", "" # Intermediate master reference and master alt for alignment
	    new_reference, new_alt = "", "" # Final combined reference and alt
	    final_position = -1 # Final position for combined result
	    skip_entry = False
	    prev_entry = ""		

	    # Print out all records as is if we have ins/ins or snp/del
	    for group in consecutive_list:
		# More than 2 consecutive records
		if len(group) > 2:
			group_size = len(group)
			snp_count, ins_count, del_count = 0,0,0
			unknown_cases, unknown_refs_alts = [],[]
			consec_snps, consec_dels = [],[] # Stores starting index and number of consecutive entries to combine from original group
			prev_id = ""
			snp_counts = 1 # Tracks number of additional times current type of variant occurs (ex: 3 snps in a row)
			del_counts = 1

			# Obtain counts of snps, ins, and deletions --> create list of type of each variant in current group
			for index,entry in enumerate(group):
				entry_type = self.check_type(entry)[0] 
				if entry_type == "snp":
					snp_count += 1
					unknown_cases.append("snp")

				elif entry_type == "insertion":
					ins_count += 1
					unknown_cases.append("insertion")

				elif entry_type == "deletion":
					del_count += 1	
					unknown_cases.append("deletion")

				unknown_refs_alts.append([entry.pos, entry.ref, "".join(entry.alts)])
				
			# consec_dels and consec_snps should now contain list of lists with: [index, number of entries of same type in a row]

			# All snps --> done
			if snp_count == group_size:
				print "all snps: ", unknown_cases
				combined_ref, combined_alt  = "",""

				for index,entry in enumerate(group):
					combined_ref += entry.ref
					combined_alt += "".join(entry.alts)

					# Store position of first item in group
					if index == 0:
						chrom = entry.chrom
						pos = entry.pos
						id = entry.id
						qual = entry.qual
						filter = entry.filter
						info = entry.info
						format = entry.format
						samples = entry.samples
						

				# Call constructor for new record object and then add this record object to merged_variants
				vcf_entry = vcf.model._Record(
					chrom,
					pos,
					id,
					combined_ref,
					combined_alt,	
					qual,
					filter,
					info,
					format,
					samples
				)
				merged_variants.append(vcf_entry)
				continue

			# All insertions --> done
			elif ins_count == group_size:
				# Will skip current group and continue after next if below
				print "all ins: ", unknown_cases
				skip_entry = True

			# All deletions --> done
			elif del_count == group_size:
				print "all dels: ", unknown_cases
				# Get ref (unique union of all consecutive refs)
				set_refs = []
				combined_refs = ""
				for entry in group:
					intermediate = self.populate_list(entry.ref, entry.pos)
					set_refs.append(intermediate)
				set_refs = set(set_refs)
				sorted_refs = sorted(set_refs, key=itemgetter(1)) # Sort set of items by position number
				for index,entry in enumerate(sorted_refs):
					combined_refs += entry.ref
					if index == 0:
						chrom = entry.chrom
						pos = entry.pos
						id = entry.id
						qual = entry.qual
						filter = entry.filter
						info = entry.info
						format = entry.format
						samples = entry.samples
						
				first_entry = group[0] # pysam record object
				combined_alts = first_entry.alts[0] # the first letter in the tuple will be the new alt
				print "del/del case, combined refs is: ", combined_refs	
				print "del/del case, combined alts is: ", combined_alts	
				# Call constructor for new record object and then add this record object to merged_variants
				vcf_entry = vcf.model._Record(
					chrom,
					pos,
					id,
					combined_refs,
					combined_alts,	
					alt,
					qual,
					filter,
					info,
					format,
					samples
				)
				continue

			# Combine 2 or more consecutive variants of same type (only snps and and dels first)
			# Create new merged snp entrie(s)
			# Search for consecutive snps and modify group with merged record
			while contains_consec(group,"snp")[0] == True: 
				combined_ref = ""
				combined_alt = ""
				start_position = contains_consec(group,"snp")[1] # Keep original copy of start
				start_pos_copy = start_position # Create copy of start position to modify
				consec_types = contains_consec(group,"snp")[2] # Stores number of variants of the same type in a row

				for x in range(consec_types):
					cur_record = group[start_pos_copy]
					record_template = group[start_position]

					# If current record is a pysam record
					if isinstance(cur_record,pysam.cbcf.VariantRecord):
						# Concatenate all refs and alts which are all snps
						combined_ref += cur_record.ref
						combined_alt += "".join(cur_record.alts)

						# Store information of first item in group and use for combined entry
						chrom = record_template.chrom
						pos = record_template.pos
						id = record_template.id
						qual = record_template.qual
						filter = record_template.filter
						info = record_template.info
						format = record_template.format
						samples = record_template.samples
					

					# Current record is a pyvcf record
					elif isinstance(cur_record,vcf.model._Record):
						pyvcf_record = group[start_pos_copy]
						combined_ref += cur_record.REF
						combined_alt += "".join(cur_record.ALT)

						# Store information of first item in group and use for combined entry
						chrom = record_template.CHROM
						pos = record_template.POS
						id = record_template.ID
						qual = record_template.QUAL
						filter = record_template.FILTER
						info = record_template.INFO
						format = record_template.FORMAT
						samples = record_template.SAMPLES

					start_pos_copy += 1 # Go to next consecutive position
						
				# Replace old records with merged record in group
				# Create new pyvcf record object, add to group, then remove old, unmerged record objects from consecutive group
				new_record = vcf.model_Record(
					chrom,
					pos,
					id,
					combined_ref,
					combined_alt,	
					qual,
					filter,
					info,
					format,
					samples
				)
				
				group[start_position:start_position + consec_types] = [new_record]
			"""
			# Consecutive snps should now be merged
			# Search for consecutive dels and modify group with merged record
			while contains_consec(group,"del")[0] == True:
				combined_ref = ""
				combined_alt = ""
				start_position = contains_consec(group,"del")[1] # Keep original copy of start
				start_pos_copy = start_position # Create copy of start position to modify
				consec_types = contains_consec(group,"del")[2] # Stores number of variants of the same type in a row

				for x in range(consec_types):
					cur_record = group[start_pos_copy]

					if isinstance(cur_record,pysam.cbcf.VariantRecord):
							
					elif isinstance(cur_record,vcf.model._Record):
			"""
			################### continue here
			prev_type, cur_type = "",""
			ins_del, del_ins = [],[] # Store indices of start positions from intermediate list

			# Next find ins/del's and del/ins's found in intermediate list
			for index,variant in enumerate(intermediate_list):
				cur_type = self.check_type(variant)[0]
				
				# If no the first item in intermediate list
				if index != 0:
					if prev_type == "ins" and cur_type == "del":
						ins_del.append(index)
					elif prev_type == "del" and cur_type == "ins":
						del_ins.append(index)

				prev_type = cur_type

			# Merge del/ins's and ins/del's found in intermediate list
			
			group = intermediate_list

			# New intermediate list should have either 2 or one record at this point
			if len(group) == 1:
				skip_entry = True
			
			# Two consecutive insertions, write out whole group
			#elif == True:
			#	skip_entry = True	

			# Print out what unknown case we have # --> unknown cases are printed
			else:
				print "unknown case: ", unknown_cases, unknown_refs_alts
				print "####################"


 		# For groups with a size larger than 2, we will keep all records in this group as is
		if skip_entry == True:
		#	print "skipping this entry"
			record_objects = []
			for item in group:
				record_objects.append(item)
			merged_variants += record_objects	
			skip_entry = False
			continue # Skip to next group

		# Check if the length of the list is equal to 2 (either originally or after compression from previous step)
		if len(group) == 2: 
			# Keep track of indices as we loop through every entry of each group to be merged
			for index, cur_entry in enumerate(group):
			    if index == 0: # We are on the first entry of the current consec group
				previous_id = self.check_type(cur_entry)[0]

			    else:
				current_id = self.check_type(cur_entry)[0]
				# First id is an insertion 
				if previous_id == "insertion":
					if current_id == "insertion": # --> done
						# Add block of all records to file
						#print "ins/ins"
						skip_entry = True
						break # Break out of for loop and go to skip check at bottom


					# Tal's code	
					elif current_id == "deletion": # --> needs call to pysam record constructor
					#	print "ins/del"

						#concatenate
						ref1 = self.populate_list(prev_entry.ref, prev_entry.pos)
						ref2 = self.populate_list(cur_entry.ref, cur_entry.pos)
						alt1 = self.populate_list("".join(prev_entry.alts), prev_entry.pos)
						alt2 = self.populate_list("".join(cur_entry.alts), cur_entry.pos)

						# Populated lists
						combined_ref = ref1 + ref2
						combined_alt = alt1 + alt2
						new_ref,new_alt=[],[]
						# Go through lists of master references and alts and add differing bases to final output
						if len(combined_ref)==len(combined_alt):
						    first_occurence = -1
						    for i,j in zip(combined_ref,combined_alt):
							if i[0]!=j[0]:
							    # store position of first mismatch, relative to reference
							    if first_occurence == -1:
								new_pos = i[1] 
								first_occurence += 1

							    new_ref.append(i[0])
							    new_alt.append(j[0])

						new_refs = "".join(new_ref)
						new_alts = "".join(new_alt)
						chrom = prev_entry.chrom
						pos = prev_entry.pos
						id = prev_entry.id
						qual = prev_entry.qual
						filter = prev_entry.filter
						info = prev_entry.info
						format = prev_entry.format
						samples = prev_entry.samples

						vcf_entry = vcf.model._Record(
							chrom,
							pos,
							id,
							new_refs,
							new_alts,	
							qual,
							filter,
							info,
							format,
							samples
						)
						merged_variants.append(vcf_entry)

					elif current_id == "snp": # --> need call to pysam record constructor
						combined_ref = prev_entry.ref + cur_entry.ref
						combined_alt = "".join(prev_entry.alts) + "".join(cur_entry.alts)
						chrom = prev_entry.chrom
						pos = prev_entry.pos
						id = prev_entry.id
						qual = prev_entry.qual
						filter = prev_entry.filter
						info = prev_entry.info
						format = prev_entry.format
						samples = prev_entry.samples
	
						vcf_entry = vcf.model._Record(
							chrom,
							pos,
							id,
							combined_ref,
							combined_alt,	
							qual,
							filter,
							info,
							format,
							samples
						)
						merged_variants.append(vcf_entry)
						#print "ins/snp"
						

				# First id is a deletion 
				elif previous_id == "deletion":
					if current_id == "insertion": # --> need call to pysam record constructor
						#print "del/ins"
						if cur_entry.pos == 7614:
							print "entered correct case"
						ref1 = self.populate_list(prev_entry.ref, prev_entry.pos)
						ref2 = self.populate_list(cur_entry.ref, cur_entry.pos)
						alt1 = self.populate_list("".join(prev_entry.alts), prev_entry.pos)
						alt2 = self.populate_list("".join(cur_entry.alts), cur_entry.pos)	
						combined_ref = sorted(set(ref1+ref2), key=itemgetter(1)) # populated list
						combined_alt = alt1 # populated list

						# Add rest of bases in alt2, except first base
						for index,entry in enumerate(alt2):
							# Skip artifact and append base and position to populated list
							if index != 0:
								combined_alt.append(entry)

						combined_alt = sorted(combined_alt, key=itemgetter(1)) 
						# Get diffs between two lists 
						if len(combined_ref)==len(combined_alt):
						    new_ref,new_alt= "",""
							
						    # Gives position to return
						    first_occurence = -1
						    for i,j in zip(combined_ref,combined_alt):
							if i[0]!=j[0]:
								# iterate through populated lists and store position of first mismatch, relative to reference
								if first_occurence == -1:
									new_pos = i[1]
									first_occurence += 1
								new_ref += i[0]
								new_alt += j[0]

						chrom = prev_entry.chrom
						pos = new_pos
						id = prev_entry.id
						qual = prev_entry.qual
						filter = prev_entry.filter
						info = prev_entry.info
						format = prev_entry.format
						samples = prev_entry.samples

						vcf_entry = vcf.model._Record(
							chrom,
							new_pos,
							id,
							new_ref,
							new_alt,	
							qual,
							filter,
							info,
							format,
							samples
						)
						merged_variants.append(vcf_entry)
						continue

					elif current_id == "deletion":# --> need call to pysam record constructor
						print "del/del"
						ref1_list = self.populate_list(prev_entry.ref, prev_entry.pos)
						ref2_list = self.populate_list(cur_entry.ref, cur_entry.pos)
						set_combined_refs = set(ref1_list + ref2_list) # unique union of refs
						sorted_combined_refs = sorted(set_combined_refs, key=itemgetter(1)) # sort unique refs by position number (second item in tuple)
						combined_refs = ""
						for unique_union in sorted_combined_refs:
							combined_refs += unique_union[0]
						combined_alts = prev_entry.alts[0] # only the first alt variant remains
						print "group is: "
						print prev_entry.pos, prev_entry.ref, "".join(prev_entry.alts)
						print cur_entry.pos, cur_entry.ref, "".join(cur_entry.alts)
						print "combined refs is: ", combined_refs
						print "combined alts is: ", combined_alts
						print "####################"
						continue
					elif current_id == "snp": # --> done
						# Write out block of lines to file
						print "del/snp"
						skip_entry = True
						break # Break out of for loop and go to skip check at bottom

				# First id is a snp (concatenate all refs and alts no matter what the cur_entry is)
				elif previous_id == "snp": 
					combined_ref = prev_entry.ref + cur_entry.ref
					combined_alt = "".join(prev_entry.alts) + "".join(cur_entry.alts)
					chrom = prev_entry.chrom
					new_pos = prev_entry.pos
					id = prev_entry.id
					qual = prev_entry.qual
					filter = prev_entry.filter
					info = prev_entry.info
					format = prev_entry.format
					samples = prev_entry.samples

					vcf_entry = vcf.model._Record(
						chrom,
						new_pos,
						id,
						combined_ref,
						combined_alt,	
						qual,
						filter,
						info,
						format,
						samples
					)
					merged_variants.append(vcf_entry)
			    	# Update previous
			    	previous_id = current_id
		    	    prev_entry = cur_entry

			# Check if very last group should be printed out
			if skip_entry == True:
				print "skipping this entry"
				record_objects = []
				for item in group:
					record_objects.append(item)
				merged_variants += record_objects # Combine list of record_objects with larger list of record objects	
	    return merged_variants




def main():
    vcf_in = VariantFile(sys.argv[1])
    vcf_out = VariantFile('combined_variants.vcf', 'w', header=vcf_in.header)
    vcf_out.close()
    instance = CombineConsecVariants() # Create instance of class object
    records_to_write1 = instance.set_consecutive_entries(sys.argv[1])
    consecutive_list =  instance.get_consec_list() # call getter for property of instance of class object
    records_to_write2 = instance.combine_variants(consecutive_list) # Return list of record objects
    print "lenth of records1 is: ", len(records_to_write1)
    print "lenth of records2 is: ", len(records_to_write2)

    # Sort pysam records by position before writing to new vcf file
    merged_records = records_to_write1 + records_to_write2

    # Sort records by position number
    records_dictionary = {}
    for record in merged_records:
	# Record is a pysam VariantFile object
	if isinstance(record,pysam.cbcf.VariantRecord):
		records_dictionary[record.pos] = record
	# Record is a pyvcf record object
	elif isinstance(record,vcf.model._Record):
		records_dictionary[record.POS] = record

    # Order the dictionary by key which will be position numbers
    records_dictionary = collections.OrderedDict(sorted(records_dictionary.items()))
    # Convert all pysam and pyvcf objects to strings which will be written to the vcf file
    vcf_strings_to_print = []
    vcf_out = open('combined_variants.vcf','a')

    for key in records_dictionary:
    	info_line, filter_line = "", ""

	if isinstance(records_dictionary[key],pysam.cbcf.VariantRecord):
		record = records_dictionary[key]
		for key in record.info.keys():
			if key == "CSQ":
				info_entry = "CSQ=" + ",".join(record.info[key])
			else:
				info_entry = key + "=" + str(record.info[key]) + ";"
			info_line += info_entry
		line = record.chrom + "\t" + str(record.pos) + "\t" + "." + "\t" + record.ref + "\t" + "".join(record.alts) + "\t" + str(record.qual) + "\t" + "".join(record.filter) + "\t" + info_line + "\n" 
		vcf_out.write(line)
		
	elif isinstance(records_dictionary[key],vcf.model._Record):
		record = records_dictionary[key]
		for key in record.INFO.keys():
			if key == "CSQ":
				info_entry = "CSQ=" + ",".join(record.INFO[key])
			else:
				info_entry = key + "=" + str(record.INFO[key]) + ";"
			info_line += info_entry
		line = record.CHROM + "\t" + str(record.POS) + "\t" + "." + "\t" + record.REF + "\t" + "".join(record.ALT) + "\t" + str(record.QUAL) + "\t" + "".join(record.FILTER) + "\t" + info_line + "\n" 
		vcf_out.write(line)

			
if __name__ == "__main__":
    main()
