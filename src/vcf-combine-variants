#!/usr/bin/env python
# Kellie Kim August 24, 2016
# Usage (if reading from a zipped file): python vcf-combine-variants.py -f file.vcf.gz
# Default: python vcf-combine_variants.py --> reads vcf from sys.stdin which is being piped in Makefile
# Combines consecutive snps/deletions/insertions

from __future__ import print_function
import csv
import os
from operator import itemgetter
import sys, getopt
import vcf
import collections
import argparse
import gzip

GROUPHOME = os.environ['GROUPHOME']
VCF_FILE = GROUPHOME + '/data/variants/pbhoover/1-0109.high-impact.vcf.gz'

# lambda function used to determine if 2 lists are equivalent
compare = lambda x, y: collections.Counter(x) == collections.Counter(y)

__program__ = 'vcf-combine-variants.py'
__version__ = '1.0.2'

# infile = a vcf.gz file
# output = a list of lists containing groups of consecutive variants
class CombineConsecVariants():
    def __init__(self):
        # Initialize properties
        self.clist = [] # List containing consecutive positions
        self.dlist = [] # List containing duplicate entries

    # getters
    def get_consec_list(self):
        return self.clist

    def get_dup_list(self):
        return self.dlist

    #check if a pair of ref alt is a snp, insertion or deletion, also returns how many bases are inserted/deleted
    # entry is a pyvcf record
    # returns tuple of length 2: [variant type, length of insertion/deletion]
    def check_type(self, entry):
	# print(entry)
        ref = entry.REF
        alt = entry.ALT[0]

        if len(ref)==len(alt):
            return "snp", 0
        if len(ref)<len(alt):
            insert_len=len(alt)-len(ref)
            return "insertion", insert_len
        if len(ref)>len(alt):
            delete_len=len(ref)-len(alt)
            return "deletion", delete_len
        else:
            print("something is wrong")

    # setters
    def set_consec_list(self, consecutive_list):
        self.clist = consecutive_list

    def set_dup_list(self, duplicate_list):
        self.dlist = duplicate_list

    # Creates list with index for each base in vcf record
    # ref_alt = ref or alt alleles: ex- "ACCT"
    # returns list of tuples
    def populate_list(self,ref_alt,pos):
        # List will contain base and position: ex-[['A',301],['C',302]]
        ref_alt_list=[]
        for i,base in enumerate(ref_alt):
            ref_alt_list.append((base,i+pos))
        return ref_alt_list

    # Returns index of a del/snp found, else returns index of -1
    def contains_del_snp(self, group):
        index = -1
        prev_type = ""
        for i,item in enumerate(group):
            cur_type = self.check_type(item)[0]
            if (cur_type == "snp") and (prev_type == "deletion"):
                index = i
                return  index
            prev_type = self.check_type(item)[0]
        return index

    # Checks if the group of consecutive variants passed in has consecutive snps, returns if there are either consecutive snps or dels, the index of the first occurrence and the length
    def contains_consec(self, group, snp_or_del):
        contains_consec = -1 # Index representing start of consec snps/dels
        length = -1 # Number of consecutive snps/dels counted in total
        prev_type = ""
        snp_counts = 1
        del_counts = 1
        prev_type = "" # simulates parent pointer
        prev_entry, cur_entry = None,None

        for index,cur_entry in enumerate(group):
            cur_type = self.check_type(cur_entry)[0]
	    # print(cur_type)
	    # print(index, len(group) - 1, cur_entry)

            # First entry in group
            if index == 0:
                prev_type = cur_type
                prev_entry = cur_entry
            else:
		# print(cur_entry)
                # Found at least 2 consecutive entries that must be snp/snp or del/del
                if (cur_type == snp_or_del) and (prev_type == snp_or_del):
                    next_pos = prev_entry.POS + 1
                    # Increase counts only if positions are also consecutive
                    if cur_entry.POS == next_pos:
                        if prev_type == "snp":
			    # print(cur_type)
                            snp_counts += 1
                            if contains_consec == -1:
                                # Set start index of consec snps
                                contains_consec = index - 1

                        elif prev_type == "deletion":
                            del_counts += 1
                            if contains_consec == -1:
                                # Set start index of consec dels
                                contains_consec = index - 1
		
                elif prev_type != cur_type or index == (len(group) - 1):
                    if (snp_counts > 1) and (snp_or_del == "snp"):
                        length = snp_counts	
                        return contains_consec,length
                    elif (del_counts > 1) and (snp_or_del == "deletion"):
                        length = del_counts
                        return contains_consec,length

            # Update parent pointer to last current entry
            prev_entry = cur_entry
            prev_type = self.check_type(prev_entry)[0]
	if length == -1:
	    if snp_counts > 1 and snp_or_del == 'snp':
		length = snp_counts
	    elif del_counts > 1 and snp_or_del == 'deletion':
		length = del_counts
        # No consecutive snps or dels found
        return	contains_consec,length

    # Function checks if the current group of consecutive entries has contains either a ins/del or del/ins
    # Input: group, Output: (index of first occurrence of ins/del or del/ins)
    def ins_del(self, group):
        prev_entry_type, cur_entry_type = "",""
        for index,entry in enumerate(group):
            cur_entry_type = self.check_type(entry)[0]
            if index != 0:
                if (cur_entry_type == "deletion") and (prev_entry_type == "insertion"):
                    return index-1,"ins_del"
                elif (cur_entry_type == "insertion") and (prev_entry_type == "deletion"):
                    return index-1,"del_ins"
            prev_entry_type = cur_entry_type
        return -1, None # No ins_del or del_ins found

    def set_consecutive_entries(self, infile):
        """
        Groups consecutive variants into lists contained within a list.
        """
        # Step 1: group consecutive positions into lists ([[position, reference, alternate]])
        # Modeled after gerrymander by Afif
        vcf_in = vcf.Reader(filename=infile)
        vcf_out = [] # List of records which we will write to the new vcf file
        consecutives, duplicates = [], []
        block, to_process = [],[]
        distance, last_position = 0, 0
        duplicate = False
        counts = 0

	# Print header line
	with gzip.open(infile, 'rb') as f:
	    for line in f:
		row = line.rstrip('\n')
                if "#" in row:
                    print(row)
                else:
		    break
	f.close()

        # Iterate through numbered records in pyvcf file object
        for record in vcf_in:
            distance = record.POS - last_position
            # Hit duplicate entry, reset block and add block
            if distance == 0: # Duplicate entry
                duplicate = True
            # Hit non-consecutive entry or the first entry of a new block, reset block and add block
            elif distance > 1:
                # First entry in entire file, skip
                if counts == 0:
                    counts += 1
                else:
                    # Only add the block to process if the length is greater than one
                    # Extend consecutives list
                    if (len(block) > 1) and (duplicate is False):
                        consecutives.append(block)

                    # Extend duplicates list
                    elif (len(block) > 1) and (duplicate is True):
                        duplicates.append(block)
                        duplicate = False

                    # Write out single record to vcf file
                    elif len(block) == 1:
                        vcf_out.append(block[0])
                    block = []
            # Consecutive entries, append to current block
            else:
                distance = 0
            # Add a tuple containing: position, reference, alt
            block.append(record)
            last_position = record.POS

        # Add last block to it's proper place
        # If the last block contains only one entry, add it to singles block
        if (len(block) > 1) and (duplicate is False):
            consecutives.append(block)
        elif (len(block) > 1) and (duplicate is True):
            duplicates.append(block)
        else:
            vcf_out.append(block[0]) #Append last single record

        self.set_consec_list(consecutives)
        self.set_dup_list(duplicates)
        return vcf_out # Return list of SINGLE pyvcf records and dictionary of consec records

    # Expecting list of pyvcf record objects as input
    def combine_variants(self, consecutive_list):
        merged_variants = []
        previous_id, current_id = "", ""
      #  MR, MA = "", "" # Intermediate master reference and master alt for alignment
      #  new_reference, new_alt = "", "" # Final combined reference and alt
      #  final_position = -1 # Final position for combined result
        skip_entry = False
        prev_entry = ""
        counter_var = 0

        # Print out all records as is if we have ins/ins or snp/del
        for group in consecutive_list:
	#    for item in group:
	#	print(item)
            # chunk 1, more than 2 consecutive vcf records
            if len(group) > 2:
                group_size = len(group)
                snp_count, ins_count, del_count = 0, 0, 0 #Counts of each type in current group
                unknown_cases, unknown_refs_alts = [],[]
                prev_id, entry_type = "",""
                snp_counts = 1 # Tracks number of additional times current type of variant occurs (ex: 3 snps in a row)
                del_counts = 1

                # Obtain counts of snps, ins, and deletions --> create list of type of each variant in current group(ex: ['snp','ins','del']
                for index,entry in enumerate(group):
                    entry_type = self.check_type(entry)[0]
                    if entry_type == "snp":
                        snp_count += 1
                        unknown_cases.append("snp")
                    elif entry_type == "insertion":
                        ins_count += 1
                        unknown_cases.append("insertion")
                    elif entry_type == "deletion":
                        del_count += 1
                        unknown_cases.append("deletion")
                    unknown_refs_alts.append([entry.POS, entry.REF, str(entry.ALT[0])])

                # consec_dels and consec_snps should now contain list of lists with: [index, number of entries of same type in a row]
                # All snps --> done
                if snp_count == group_size:
                    combined_ref, combined_alt  = "",""
                    for index,entry in enumerate(group):
                        combined_ref += entry.REF
                        combined_alt += str(entry.ALT[0])

                    # Search for at least one hetero and index with lowest quality score
                    HETERO = False
                    filter = ""
                    lowest_qual = sys.maxint
                    index = -1 # Position of record in group with lowest quality
                    for i,record in enumerate(group):
                        if record.FILTER == "HETERO":
                            filter = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i # Store index with lowest quality score
                            lowest_qual = record.QUAL

                    if HETERO is False:
                        #Arbitrarily assign filter to the first item in group
                        filter = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = entry.POS
                    id = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    format = entry.FORMAT
                    samples = entry.samples

                    # Call constructor for new record object and then add this record object to merged_variants
                    vcf_entry = vcf.model._Record(
                        chrom,
                        pos,
                        id,
                        combined_ref,
                        combined_alt,
                        qual,
                        filter,
                        info,
                        format,
                        samples
                    )
                    merged_variants.append(vcf_entry)
                    continue # Go to next group

                # Greater than 2 consecutive insertions found--> done
                elif ins_count > 1:
                    for item in group:
                        merged_variants.append(item)
                    continue

                # All deletions --> unique union of refs and only keep first alt base
                elif del_count == group_size:
                    # Get ref (unique union of all consecutive refs)
                    set_refs = []
                    combined_refs = ""
                    for entry in group:
			# print(entry)
                        intermediate = self.populate_list(entry.REF, entry.POS)
                        set_refs += intermediate
                        #set_refs.append(intermediate)
                    set_refs = set(set_refs)
                    sorted_refs = sorted(set_refs, key=itemgetter(1)) # Sort set of items by position
                    for index,entry in enumerate(sorted_refs):
                        combined_refs += entry[0]

                    first_entry = group[0] # pyvcf record object
                    combined_alts = [first_entry.ALT[0]] # only the first letter in the tuple will be the new alt

                    # Search for at least one hetero and index with lowest quality score
                    HETERO = False
                    lowest_qual = sys.maxint
                    index = -1 # Position of record in group with lowest quality
                    filter = ""
                    for i,record in enumerate(group):
                        if record.FILTER == "HETERO":
                            filter = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i
                            lowest_qual = record.QUAL
                    if HETERO is False:
                        #Arbitrarily assign filter to the first item in group
                        filter = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = entry.POS
                    id = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    format = entry.FORMAT
                    # samples = entry.samples
		    samples_indexes = {}

                    vcf_entry = vcf.model._Record(
                        chrom,
                        pos,
                        id,
                        combined_refs,
                        combined_alts,
                        qual,
                        filter,
                        info,
                        format,
                        samples_indexes
                    )
                    merged_variants.append(vcf_entry)
                    continue

                # Merge consecutive snps
                while self.contains_consec(group,"snp")[0] != -1:
                    """
                    print("group before merging chain of snps is: ")
                    for item in group:
                        print(item)
                    """

                    combined_ref,combined_alt = "",""
                    start_position = self.contains_consec(group,"snp")[0] # Keep original copy of start
                    start_pos_copy = start_position # Create copy of start position to modify
                    consec_types = self.contains_consec(group,"snp")[1] # Stores number of variants of the same type in a row
		    # print(start_position, consec_types)

                    # Iterate over number of consecutive snps and so simple concatenation
                    for x in range(consec_types):
                        # cur_record is a pyvcf record
                        cur_record = group[start_pos_copy]
                        combined_ref += cur_record.REF
                        combined_alt += str(cur_record.ALT[0])
                        start_pos_copy += 1 # Go to next consecutive position

                    # Search for at least one hetero and index with lowest quality score
                    HETERO = False
                    lowest_qual = sys.maxint
                    index = -1 # Position of record in group with lowest quality
                    filter = ""
                    for i,record in enumerate(group):
                        if record.FILTER == "HETERO":
                            filter = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i
                            lowest_qual = record.QUAL

                    if HETERO is False:
                        #Arbitrarily assign filter to the first item in group
                        filter = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = entry.POS
                    id = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    format = entry.FORMAT
                    samples = entry.samples

                    # Replace old records with merged record in group
                    new_record = vcf.model._Record(
                        chrom,
                        pos,
                        id,
                        combined_ref,
                        combined_alt,
                        qual,
                        filter,
                        info,
                        format,
                        samples
                    )

                    # Replace old entries with single, combined pyvcf record
                    """
                    print("line 355, group was: ")
                    for member in group:
                        print(member)
                    """
                    group[start_position:start_position + consec_types] = [new_record]
                    """
                    print("line 359, group now: ")
                    for member in group:
                        print(member)
                    """
                # Merge consecutive deletions
              #  num_to_print = self.contains_consec(group, "deletion")[0]
                while self.contains_consec(group,"deletion")[0] != -1:
                    combined_ref, combined_alt = "",""
                    start_position = self.contains_consec(group,"deletion")[0]  # Keep original copy of start
                    start_pos_copy = start_position # Create copy of start position to modify
                    consec_types = self.contains_consec(group,"deletion")[1] # Stores number of variants of the same type in a row
                    first_record = group[start_position]
                    combined_refs = set()
                    # combined_alt will be only the first alt letter of first record in group
                    combined_alt = [first_record.ALT[0]]
                    refs = [] # will hold unique union of all refs in group

                    # Create populated lists for refs and get the unique union
                    for x in range(consec_types):
                        # Current record is a pyvcf record
                        cur_record = group[start_pos_copy]
                        cur_ref_list = self.populate_list(cur_record.REF,cur_record.POS) # Ex: return [['A', 306],['C', 307]] --> [base,position]
                        refs += tuple(cur_ref_list) # Convert current base to a tuple
                        start_pos_copy += 1 # Go to next consecutive position
                    combined_refs = sorted(set(refs), key=lambda x: x[1]) # sorted, populated list of all the ref bases, sort by positions
                    #print("line 469, combined refs is now: ", combined_refs)
                    for item in combined_refs:
                        combined_ref += item[0]
                    #print("line 472, combined_refs after unique union is: ", combined_refs)

                    # Search for at least one hetero and index with lowest quality score
                    # new position will be the first variant
                    first_pos = first_record.POS
                    HETERO = False
                    lowest_qual = sys.maxint
                    index = -1  # Position of record in group with lowest quality
                    FILTER = ""
                    for i, record in enumerate(group):
                        if record.FILTER == "HETERO":
                            FILTER = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i
                            lowest_qual = record.QUAL

                    if HETERO is False:
                        #Arbitrarily assign filter to the first item in group
                        FILTER = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = first_pos
                    ID = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    FORMAT = entry.FORMAT
                    samples = entry.samples
		    print(chrom, pos, ID, combined_ref, combined_alt,qual, FORMAT, samples)
		    
                    new_record = vcf.model._Record(
                        chrom,
                        pos,
                        ID,
                        combined_ref,
                        combined_alt,
                        qual,
                        FILTER,
                        info,
                        FORMAT,
                        samples
                    )
                    """
                    print("line 490: group was: ")
                    for member in group:
                        print(member)
                    """
                    group[start_position:start_position + consec_types] = [new_record]
                    """
                    print("line 494: group now")
                    for member in group:
                        print(member)
                    print("del/del while loop end of iteration")
                    """
                prev_type, cur_type = "","" # simulates parent and child points to pyvcf record objects
                ins_del, del_ins = [],[] # Store indices of start positions from intermediate list

                # Find ins/del's and del/ins's found in new intermediate list --> each case will either form 1) more snps, 2) unable to combine
                while self.ins_del(group)[0] != -1: # ex: [index,"ins_del"] or [index,"del_ins"] --> index = -1 if no ins/del, del/ins found
                    if self.ins_del(group)[1] == "ins_del":
                        # unique union for refs
                        index = self.ins_del(group)[0] # index of the ins
                        prev_entry = group[index]
                        ref1 = self.populate_list(group[index].REF, group[index].POS) # Corresponds to the insertion
                        ref2 = self.populate_list(group[index+1].REF, group[index+1].POS) # Corresponds to the deletion
                        alt1 = self.populate_list(str(group[index].ALT[0]), group[index].POS)
                        alt2 = self.populate_list(str(group[index+1].ALT[0]), group[index+1].POS)

                        # Populated lists, remove duplicate nucleotides at same positions
                        combined_ref = sorted(set(ref1+ref2), key=itemgetter(1))
                        combined_alt = sorted(set(alt1+alt2), key=itemgetter(1))
                        new_refs,new_alts="",""

                        # Go through lists of master references and alts and add differing bases to final output
                        if len(combined_ref) == len(combined_alt): # Iterate through list of: [base,position]
                            first_occurence = -1
                            # Iterate through tuples: ex: ('A', 303)
                            for i,j in zip(combined_ref,combined_alt):
                                if i[0]!=j[0]:
                                    # store position of first mismatch, relative to reference
                                    if first_occurence == -1:
                                        new_pos = i[1] # new reference genome position for combined entry
                                        first_occurence += 1
                                    new_refs += i[0]
                                    new_alts += j[0]
                        else:
                            # lengths of combined ref and alt are not equal, don't merge entire block
                            for record in group:
                                merged_variants.append(record)
                            break # Do not check for anymore ins/dels

                        # Search for at least one hetero and index with lowest quality score
                        HETERO = False
                        lowest_qual = sys.maxint
                        index = -1 # Position of record in group with lowest quality
                        filter = ""
                        for i,record in enumerate(group):
                            if record.FILTER == "HETERO":
                                filter = record.FILTER
                                HETERO = True
                            if record.QUAL < lowest_qual:
                                index = i
                                lowest_qual = record.QUAL

                        if HETERO is False:
                            #Arbitrarily assign filter to the first item in group
                            filter = group[0].FILTER
                        # Assign rest of columns from record with lowest quality score using index
                        entry = group[index]
                        chrom = entry.CHROM
                        pos = new_pos
                        id = entry.ID
                        qual = entry.QUAL
                        info = entry.INFO
                        format = entry.FORMAT
                        samples = entry.samples

                        vcf_entry = vcf.model._Record(
                            chrom,
                            pos,
                            id,
                            new_refs,
                            new_alts,
                            qual,
                            filter,
                            info,
                            format,
                            samples
                        )
                        """
                        print("line 574, found an ins/del, group was: ")
                        for members in group:
                            print(members)
                        """
                        group[index:index+1] = vcf_entry
                        """
                        print("line 578, group now: ")
                        for members in group:
                            print(members)
                        """
                        continue # Check for more ins/del or del/ins

                    elif self.ins_del(group)[1] == "del_ins":
                        index = self.ins_del(group)[0] # index of deletion
                        prev_entry = group[index]
                        ref1 = self.populate_list(group[index].REF, group[index].POS)
                        ref2 = self.populate_list(group[index+1].REF, group[index+1].POS)
                        alt1 = self.populate_list(str(group[index].ALT[0]), group[index].POS)
                        alt2 = self.populate_list(str(group[index+1].ALT[0]), group[index+1].POS)
                        combined_ref = sorted(set(ref1+ref2), key=itemgetter(1)) # unique union of populated list
                        combined_alt = alt1 # del's alt populated list

                        # Add rest of bases in alt2 populated list, except first base in populated list
                        for index,entry in enumerate(alt2):
                            # Skip artifact base and append leftover base and position to populated list
                            if index != 0:
                                # Add alt2's populated list tuples
                                combined_alt.append(entry)
                        # sort alt bases by position number
                        combined_alt = sorted(set(combined_alt), key=itemgetter(1))

                        # Get diffs between two lists
                        if len(combined_ref)==len(combined_alt):
                            new_ref,new_alt,new_pos= "","",""
                            # Gives position to return
                            first_occurence = -1
                            for i,j in zip(combined_ref,combined_alt):
                                if i[0]!=j[0]:
                                    # iterate through populated lists and store position of first mismatch, relative to reference
                                    if first_occurence == -1:
                                        new_pos = i[1]
                                        first_occurence += 1
                                    new_ref += i[0]
                                    new_alt += j[0]

                            # Search for at least one hetero and index with lowest quality score
                            HETERO = False
                            lowest_qual = sys.maxint
                            index = -1 # Position of record in group with lowest quality

                            for i,record in enumerate(group):
                                if record.FILTER == "HETERO":
                                    filter = record.FILTER
                                    HETERO = True
                                if record.QUAL < lowest_qual:
                                   index = i
                                   lowest_qual = record.QUAL

                            if HETERO == False:
                                #Arbitrarily assign filter to the first item in group
                                filter = group[0].FILTER
                            # Assign rest of columns from record with lowest quality score using index
                            entry = group[index]
                            chrom = entry.CHROM
                            pos = new_pos
                            id = entry.ID
                            qual = entry.QUAL
                            info = entry.INFO
                            format = entry.FORMAT
                            samples = entry.samples
                            vcf_entry = vcf.model._Record(
                                chrom,
                                pos,
                                id,
                                new_ref,
                                new_alt,
                                qual,
                                filter,
                                info,
                                format,
                                samples
                            )
                            """
                            print("line 653, group was: ")
                            for member in group:
                                print(member)
                            """
                            group[index:index+1] = vcf_entry
                            """
                            print("line 656, group now: ")
                            for member in group:
                                print(member)
                            """
                        else: # Lengths are not equal --> write out entire block
                            for item in group:
                                merged_variants.append(item)
                                break # do not check for anymore del/ins


                #group should now be a shortened list of either length three or greater, including at least one snp
                # Fuse any consecutive snps created if possible from last step
                while self.contains_consec(group,"snp")[0] != -1: # value will be -1 if there is no start index for a set of consecutive snps found
                    combined_ref,combined_alt = "",""
                    start_position = self.contains_consec(group,"snp")[0] # Keep original copy of start
                    start_pos_copy = start_position # Create copy of start position to modify
                    consec_types = self.contains_consec(group,"snp")[1] # Stores number of variants of the same type in a row
                    record_template = group[start_position]
                    index = self.contains_consec(group,"snp")[0]

                    # Store information of first item in group and use for combined entry
                    chrom = record_template.CHROM
                    pos = record_template.POS
                    id = record_template.ID
                    qual = record_template.QUAL
                    filter = record_template.FILTER
                    info = record_template.INFO
                    format = record_template.FORMAT
                    samples = record_template.samples

                    for x in range(consec_types): # Simple concatenation
                        # Current record is a pyvcf record, simply concatenate refs and alts since merging snps
                        cur_record = group[start_pos_copy]
                        combined_ref += cur_record.REF
                        combined_alt += str(cur_record.ALT[0])
                        start_pos_copy += 1 # Go to next consecutive position

                    # Search for at least one hetero and index with lowest quality score
                    HETERO = False
                    filter = ""
                    lowest_qual = sys.maxint
                    index = -1 # Position of record in group with lowest quality
                    for i,record in enumerate(group):
                        if record.FILTER == "HETERO":
                            filter = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i
                            lowest_qual = record.QUAL

                    if HETERO == False:
                           #Arbitrarily assign filter to the first item in group
                           filter = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = new_pos
                    id = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    format = entry.FORMAT
                    samples = entry.samples
                    # Replace old records with merged record in group
                    new_record = vcf.model._Record(
                        chrom,
                        pos,
                        id,
                        combined_ref,
                        combined_alt,
                        qual,
                        filter,
                        info,
                        format,
                        samples
                    )

                    # Replace old entries with single, combined pyvcf record
                    """
                    print("line 595, group was: ")
                    for member in group:
                        print(member)
                    """
                    group[start_position:start_position + consec_types] = [new_record]
                    """
                    print("line 599, group now: ")
                    for member in group:
                        print(member)
                    """
                # At this point, all ins/del, del/ins, consecutive snps, and consecutive dels, and are combined into new group
                # Modify group until length is 2 or write out whole group if a condition
                if len(group) == 3:
                    # There contains a del/snp --> keep records as is
                    if self.contains_del_snp(group) != -1:
                        for item in group:
                            merged_variants.append(item)
                        continue #Go to next group

                    # [snp, ins, snp] --> unique union, then substrings were alignment differs
                    elif (compare(unknown_cases, ['snp', 'insertion', 'snp']) == True) or (compare(unknown_cases, ["insertion", "snp", "deletion"]) == True):
			concatenated_ref = []
			concatenated_alt = []
                        #concatenate
			for group_record in group:
			    concatenated_ref.append((group_record.REF, group_record.POS))
			    concatenated_alt.append((str(group_record.ALT[0]), group_record.POS))
                        # ref1 = self.populate_list(prev_entry.REF, prev_entry.POS)
                        # ref2 = self.populate_list(cur_entry.REF, cur_entry.POS)
                        # alt1 = self.populate_list(str(prev_entry.ALT[0]), prev_entry.POS)
                        # alt2 = self.populate_list(str(cur_entry.ALT[0]), cur_entry.POS)

                        # Populated lists
                        # combined_ref = sorted(set(ref1+ref2),key=itemgetter(1))
                        # combined_alt = sorted(set(alt1+alt2),key=itemgetter(1))
                        combined_ref = sorted(set(concatenated_ref),key=itemgetter(1))
                        combined_alt = sorted(set(concatenated_alt),key=itemgetter(1))
			# print(combined_ref, combined_alt)
                        counter = 0
                        new_refs,new_alts = "",""
                        # Go through lists of master references and alts and add differing bases to final output
                        if len(combined_ref) == len(combined_alt):
                            first_occurence = -1
                            for i,j in zip(combined_ref,combined_alt):
                                if i[0] != j[0]:
                                    # store position of first mismatch, relative to reference
                                    if first_occurence == -1:
                                        #prev_entry = group[counter]
                                        new_pos = i[1]
                                        first_occurence += 1
                                    new_refs += i[0]
                                    new_alts += j[0]
                               # counter += 1

                        # Search for at least one hetero and index with lowest quality score
                        HETERO = False
                        filter = ""
                        lowest_qual = sys.maxint
                        index = -1 # Position of record in group with lowest quality
                        for i,record in enumerate(group):
                            if record.FILTER == "HETERO":
                                filter = record.FILTER
                                HETERO = True
                            if record.QUAL < lowest_qual:
                                index = i
                                lowest_qual = record.QUAL

                        if HETERO == False:
                               #Arbitrarily assign filter to the first item in group
                               filter = group[0].FILTER
                        # Assign rest of columns from record with lowest quality score using index
                        entry = group[index]
                        chrom = entry.CHROM
                        pos = new_pos
                        id = entry.ID
                        qual = entry.QUAL
                        info = entry.INFO
                        format = entry.FORMAT
                        samples = entry.samples
                        vcf_entry = vcf.model._Record(
                            chrom,
                            pos,
                            id,
                            new_refs,
                            new_alts,
                            qual,
                            filter,
                            info,
                            format,
                            samples
                        )
                        merged_variants.append(vcf_entry)
                        continue # Next group of consecutive variants

                    # [del, snp, ins]
                    elif compare(unknown_cases, ['deletion', 'snp', 'insertion']) == True:
                        for item in group:
                            merged_variants.append(item)
                        continue

                elif len(group) == 2:
                    # Remain in the same group and leave processing for next if statement
                    pass
                elif len(group) == 1: # Ex: ['snp','snp','snp'] --> ['snp']
                    merged_variants.append(group[0])
                    continue # Iterate to next group of consecutive variants
                elif len(group) == 4:
                    #print("case of 4 before", unknown_cases, unknown_refs_alts)
                    # [snp, insertion, snp, del]
                    combined_refs, combined_alts = "",""
                    for index, record in enumerate(group): #Simple concatenation
                        combined_refs += record.REF
                        combined_alts += str(record.ALT[0])

                    # Search for at least one hetero and index with lowest quality score
                    HETERO = False
                    filter = ""
                    lowest_qual = sys.maxint
                    index = -1 # Position of record in group with lowest quality
                    for i,record in enumerate(group):
                        if record.FILTER == "HETERO":
                            filter = record.FILTER
                            HETERO = True
                        if record.QUAL < lowest_qual:
                            index = i
                            lowest_qual = record.QUAL

                    if HETERO == False:
                           #Arbitrarily assign filter to the first item in group
                           filter = group[0].FILTER
                    # Assign rest of columns from record with lowest quality score using index
                    entry = group[index]
                    chrom = entry.CHROM
                    pos = group[0].POS # Assign position number of first variant in group
                    id = entry.ID
                    qual = entry.QUAL
                    info = entry.INFO
                    format = entry.FORMAT
                    samples = entry.samples
                    vcf_entry = vcf.model._Record(
                        chrom,
                        pos,
                        id,
                        combined_refs,
                        combined_alts,
                        qual,
                        filter,
                        info,
                        format,
                        samples
                    )
                    # print("vcf_entry is now: ", vcf_entry)
                    merged_variants.append(vcf_entry)
                    continue
                # Print out what unknown case we have # --> unknown cases are printed
                else:
                    print("unknown case: ", unknown_cases, unknown_refs_alts)
                    print("####################")

            # chunk 2
            # Check if the length of the list is equal to 2 (either originally or after compression from previous step)
            if len(group) == 2:
                # Keep track of indices as we loop through every entry of each group to be merged
                for index, cur_entry in enumerate(group):
                    if index == 0: # We are on the first entry of the current consec group
                        previous_id = self.check_type(cur_entry)[0]
                        prev_entry = cur_entry

                    else:  # on the second record
                        current_id = self.check_type(cur_entry)[0]
                        # First id is an insertion
                        if previous_id == "insertion":
                            if current_id == "insertion": # --> done
                                # Add block of all records to file
                                #print "ins/ins"
                                for item in group:
                                    merged_variants.append(item)
                                break  # Break out of for loop on line 628

                            elif current_id == "deletion": # --> needs call to pyvcf record constructor
                                #concatenate
                                ref1 = self.populate_list(prev_entry.REF, prev_entry.POS)
                                ref2 = self.populate_list(cur_entry.REF, cur_entry.POS)
                                alt1 = self.populate_list(str(prev_entry.ALT[0]), prev_entry.POS)
                                alt2 = self.populate_list(str(cur_entry.ALT[0]), cur_entry.POS)

                                # Populated lists
                                combined_ref = ref1 + ref2
                                combined_alt = alt1 + alt2
                                new_refs,new_alts= "",""
                                # Go through lists of master references and alts and add differing bases to final output
                                if len(combined_ref)==len(combined_alt):
                                    first_occurence = -1
                                    for i,j in zip(combined_ref,combined_alt):
                                        if i[0]!=j[0]:
                                            # store position of first mismatch, relative to reference
                                            if first_occurence == -1:
                                                new_pos = i[1]
                                                first_occurence += 1
                                            new_refs += i[0]
                                            new_alts += j[0]

                                    # Search for at least one hetero and index with lowest quality score
                                    HETERO = False
                                    lowest_qual = sys.maxint
                                    index = -1 # Position of record in group with lowest quality
                                    for i,record in enumerate(group):
                                        if record.FILTER == "HETERO":
                                            filter = record.FILTER
                                        HETERO = True
                                        if record.QUAL < lowest_qual:
                                            index = i
                                        lowest_qual = record.QUAL
                                    if HETERO == False:
                                        #Arbitrarily assign filter to the first item in group
                                        filter = group[0].FILTER
                                        # Assign rest of columns from record with lowest quality score using index
                                        entry = group[index]
                                        chrom = entry.CHROM
                                        pos = new_pos
                                        id = entry.ID
                                        qual = entry.QUAL
                                        info = entry.INFO
                                        format = entry.FORMAT
                                        samples = entry.samples
                                        vcf_entry = vcf.model._Record(
                                            chrom,
                                            pos,
                                            id,
                                            new_refs,
                                            new_alts,
                                            qual,
                                            filter,
                                            info,
                                            format,
                                            samples
                                        )
                                        merged_variants.append(vcf_entry)

                            elif current_id == "snp": # done
                                # Keep both records as two separate entries
                                merged_variants.append(prev_entry)
                                merged_variants.append(cur_entry)
                                break  # exit out of loop on line 628

                        # First id is a deletion
                        elif previous_id == "deletion":
                            if current_id == "insertion": # --> done
                                #print "del/ins"
                                ref1 = self.populate_list(prev_entry.REF, prev_entry.POS)
                                ref2 = self.populate_list(cur_entry.REF, cur_entry.POS)
                                alt1 = self.populate_list(str(prev_entry.ALT[0]), prev_entry.POS)
                                alt2 = self.populate_list(str(cur_entry.ALT[0]), cur_entry.POS)
                                combined_ref = sorted(set(ref1+ref2), key=itemgetter(1)) # populated list
                                combined_alt = alt1 # populated list

                                # Add rest of bases in alt2, except first base in populated list
                                for index, entry in enumerate(alt2):
                                    # Skip artifact and append base and position to populated list
                                    if index != 0:
                                        combined_alt.append(entry)

                                combined_alt = sorted(combined_alt, key=itemgetter(1))
                                # Get diffs between two lists
                                if len(combined_ref)==len(combined_alt):
                                    #print "lengths are the same!!!"
                                    new_ref, new_alt= "", ""

                                    # Gives position to return
                                    first_occurence = -1
                                    for i,j in zip(combined_ref,combined_alt):
                                        if i[0] != j[0]:
                                            # iterate through populated lists and store position of first mismatch, relative to reference
                                            if first_occurence == -1:
                                                new_pos = i[1]
                                                first_occurence += 1
                                            new_ref += i[0]
                                            new_alt += j[0]

                                    # Search for at least one hetero and index with lowest quality score
                                    HETERO = False
				    filter = ''
                                    lowest_qual = sys.maxint
                                    index = -1 # Position of record in group with lowest quality
                                    for i,record in enumerate(group):
                                        if record.FILTER == "HETERO":
                                            filter = record.FILTER
                                        HETERO = True
                                        if record.QUAL < lowest_qual:
                                            index = i
                                            lowest_qual = record.QUAL
                                    if HETERO == False:
                                        #Arbitrarily assign filter to the first item in group
                                        filter = group[0].FILTER
                                    # Assign rest of columns from record with lowest quality score using index
                                    entry = group[index]
                                    chrom = entry.CHROM
                                    pos = new_pos
                                    id = entry.ID
                                    qual = entry.QUAL
                                    info = entry.INFO
                                    format = entry.FORMAT
                                    samples = entry.samples
                                    vcf_entry = vcf.model._Record(
                                        chrom,
                                        new_pos,
                                        id,
                                        new_ref,
                                        new_alt,
                                        qual,
                                        filter,
                                        info,
                                        format,
                                        samples
                                    )
                                    merged_variants.append(vcf_entry)
                                    continue

                                # Lengths are not equal, two entries in del/ins can't be merged
                                else:
                                    merged_variants.append(prev_entry)
                                    merged_variants.append(cur_entry)
                                    break

                            elif current_id == "deletion":# done
                                #print "del/del"
                                ref1_list = self.populate_list(prev_entry.REF, prev_entry.POS)
                                ref2_list = self.populate_list(cur_entry.REF, cur_entry.POS)
                                set_combined_refs = set(ref1_list + ref2_list) # unique union of refs
                                sorted_combined_refs = sorted(set_combined_refs, key=itemgetter(1)) # sort unique refs by position number (second item in tuple)
                                combined_refs = ""
                                for unique_union in sorted_combined_refs:
                                    combined_refs += unique_union[0]
                                combined_alts = str(prev_entry.ALT[0]) # only the first alt variant remains
                            #	print "line 764, prev_entry.ALT[0] is: ", str(prev_entry.ALT[0])
                                continue

                            elif current_id == "snp": # --> done
                                # Write out block of lines to file
                                #print "del/snp"
                                for item in group:
                                    merged_variants.append(item)
                                break  # Break out of for loop and go to skip check at bottom

                        # First id is a snp (only concatenate all refs and alts if cur_entry is also a snp)
                        elif previous_id == "snp":
                            # Leave two entries as is
                            if (current_id == "ins") or (current_id == "del"):
                                for item in group:
                                    merged_variants.append(item)
                                break # Break out of for loop on line 628
                            # Simple concatenation ONLY if the snps are still consecutive (they might not be after intermediate merging)
                            elif current_id == "snp":
                                # snps are still consecutive
                                if cur_entry.POS == prev_entry.POS + 1:
                                    if len(prev_entry.ALT) == 1:
                                        prev_alt = prev_entry.ALT[0]
                                    else:
                                        prev_alt = str(prev_entry.ALT[0])
                                    if len(cur_entry.ALT) == 1:
                                        cur_alt = cur_entry.ALT[0]
                                    else:
                                        cur_alt = str(cur_entry.ALT[0])
                                    combined_ref = prev_entry.REF + cur_entry.REF
                                    combined_alt = str(prev_alt) + str(cur_alt)

                                    # Search for at least one hetero and index with lowest quality score
                                    HETERO = False
                                    lowest_qual = sys.maxint
                                    index = -1 # Position of record in group with lowest quality

                                    for i,record in enumerate(group):
                                        if record.FILTER == "HETERO":
                                            filter = record.FILTER
                                            HETERO = True
                                        if record.QUAL < lowest_qual:
                                            index = i
                                            lowest_qual = record.QUAL
                                        if HETERO == False:
                                            #Arbitrarily assign filter to the first item in group
                                            filter = group[0].FILTER
                                    # Assign rest of columns from record with lowest quality score using index
                                    entry = group[index]
                                    chrom = entry.CHROM
                                    pos = group[0].POS # new position will be first entry in group
                                    id = entry.ID
                                    qual = entry.QUAL
                                    info = entry.INFO
                                    format = entry.FORMAT
                                    samples = entry.samples
                                    vcf_entry = vcf.model._Record(
                                        chrom,
                                        pos,
                                        id,
                                        combined_ref,
                                        combined_alt,
                                        qual,
                                        filter,
                                        info,
                                        format,
                                        samples
                                    )
                                    merged_variants.append(vcf_entry)
                                # Nonconsecutive snps, leave records as is
                                elif cur_entry.POS != prev_entry.POS + 1:
                                    for item in group:
                                        merged_variants.append(item)
                                    break

                            # Update previous at the end of each iteration of the for loop
                            previous_id = current_id
                            prev_entry = cur_entry

        return merged_variants

    def combine_dups(self, duplicate_list):
        merged_variants = []
        for entry in duplicate_list:
            for index,item in enumerate(entry):
                merged_variants.append(item)
        return merged_variants

def main():

    parser = argparse.ArgumentParser(description=globals()['__doc__'])
    parser.add_argument('-i','--input',help='Read in VCF file')
    #parser.add_argument('-o','--output',default=sys.stdout,type=argparse.FileType('wab'),help='Write to OUT_FILE rather than sys.stdout')
    args = parser.parse_args()

    #outfile = open(args.output, 'wab')
    #vcf_writer = csv.writer(args.output, delimiter='\t')

    """
    if args.output and args.output != '-':
        sys.stdout = open(args.output, 'wab')

    else:
    """

    vcf_template = vcf.Reader(os.devnull)
    vcf_template.metadata['fileformat'] = 'VCFv4.0'
    vcf_template.metadata['source'] = [__program__ + 'V' + __version__]

    vcf_template.filters['LOW'] = vcf.parser._Filter(
        'LOW','Position with too low of depth')
    vcf_template.filters['NO'] = vcf.parser._Filter(
        'NO', 'Does not meet criteria to call variant')
    vcf_template.filters['HETERO'] = vcf.parser._Filter(
        'HETERO', 'Enough support to call reference and variant (mixed population)')

    vcf_template.infos['RSR'] = vcf.parser._Info(
        'RSR',1,'Integer','Reference-supporting reads')
    vcf_template.infos['VSR'] = vcf.parser._Info(
        'VSR',1,'Integer','Variant-supporting reads')
    # TODO - This is better represented in VCF natively
    vcf_template.infos['VF'] = vcf.parser._Info(
        'VF',1,'Float','Variant frequency')
    vcf_template.infos['DP'] = vcf.parser._Info(
        'DP',1,'Integer','Read Depth')

    vcf_template._column_headers = [
        'CHROM',
        'POS',
        'ID',
        'REF',
        'ALT',
        'QUAL',
        'FILTER',
        'INFO'
    ]
    instance = CombineConsecVariants()  # Create instance of class object

    # Infile handling-select to read in from either a file or std.in
    """
    opts, args = getopt.getopt(sys.argv[1:], "f:o:")
    vcf_source = ""
    for opt, arg in opts:
        if opt == '-f':
            vcf_source = arg
        else:  # Default reads from std.in
            vcf_source = sys.stdin
        if opt == '-o':  # Write to output arg given
            header_writer = vcf.Writer(open(arg, 'wb'), vcf_template)  # Write header to file
            vcf_out = open(arg, 'wab')  # Create file stream to append to file
        else:  # Default write to stdout
            vcf_out = sys.stdout
            header_writer = vcf.Writer(open(arg, 'wb'), vcf_template)
    """
    # records_to_write1 = instance.set_consecutive_entries(vcf_source)
    records_to_write1 = instance.set_consecutive_entries(args.input)
    consecutive_list = instance.get_consec_list() # call getter for property of instance of class object
    duplicate_list = instance.get_dup_list()
    records_to_write2 = instance.combine_variants(consecutive_list) # Return list of record objects
    records_to_write3 = instance.combine_dups(duplicate_list) # List of duplicate records

    # for records in records_to_write2:
    #	print(records)

    # Sort pyvcf records by position before writing to new vcf file
    merged_records = records_to_write1 + records_to_write2 + records_to_write3
    sorted_records = sorted(merged_records, key=lambda x: x.POS)  # sort all records to be written by position
    #header_writer = vcf.Writer(open('combined_variants.vcf', 'wb'), vcf_template)
    #vcf_out = open('combined_variants.vcf', 'wab')
    #vcf_writer = csv.writer(vcf_out, delimiter="\t")

    for record in sorted_records:
        info_line, filter_line = "", ""
	# print(record)
        for key in record.INFO.keys():
            RSR, VSR, VF, DP, info_line = "", "", "", "", ""
            RSR = "RSR=" + str(record.INFO["RSR"]) + ";"
            VSR = "VSR=" + str(record.INFO["VSR"]) + ";"
            VF = "VF=" + str(record.INFO["VF"]) + ";"
            DP = "DP=" + str(record.INFO["DP"]) + ";"
            # CSQ = "CSQ=" + ",".join(record.INFO["CSQ"])
            info_line = RSR + VSR + VF + DP

            # Check if filter tuple is empty (means PASS implicitly, must make this explicit manually)
            filter_line = record.FILTER
        if not filter_line:
            filter_line = "PASS"
        else:
            filter_line = "".join(record.FILTER)
        final_record = [record.CHROM, str(record.POS), ".", record.REF, ''.join(str(alt) for alt in record.ALT), str(record.QUAL), filter_line, info_line]
        print("\t".join(final_record))

if __name__ == "__main__":
    main()
